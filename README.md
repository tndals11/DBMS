# 📌 DBMS 기초 학습 정리

---

## 데이터베이스란?

| 용어                      | 설명                                                         |
|--------------------------|------------------------------------------------------------|
| **DB (Database)**        | 데이터를 저장하는 공간                                         |
| **DBMS (Database Management System)** | 데이터를 효율적으로 관리할 수 있는 소프트웨어                      |
| **RDBMS (Relational DBMS)**           | 데이터를 테이블 형태로 저장하고, 테이블 간의 **관계(Relation)**를 통해 관리 |

---

### 🧱 테이블 구성 요소

- **Table (테이블)**: 데이터가 저장되는 기본 단위  
- **Column (열, 속성)**: 데이터의 속성(데이터 유형)  
- **Row (행, 레코드)**: 고유한 데이터 집합 (한 행 = 하나의 레코드)  
- **Key (키)**: 각 레코드를 식별하기 위한 속성 (기본키, 외래키 등)

---

# 🛠️ SQL 언어

> SQL은 DBMS에서 데이터를 **정의, 조작, 제어**하기 위해 사용되는 표준 프로그래밍 언어입니다.

### SQL 분류

- **DDL (Data Definition Language)** : 데이터 정의
- **DML (Data Manipulation Language)** : 데이터 조작
- **DCL (Data Control Language)** : 데이터 제어

---

### 📐 DDL (Data Definition Language)

> 데이터베이스 및 테이블의 구조를 생성, 수정, 삭제할 때 사용합니다.

| 명령어      | 설명                        |
|-------------|-----------------------------|
| `CREATE`    | DB 또는 테이블 생성          |
| `ALTER`     | 기존 구조 수정              |
| `DROP`      | 구조체 삭제 (완전 삭제)     |
| `TRUNCATE`  | 데이터만 삭제, 구조 유지     |

---

## ✍️ DML (Data Manipulation Language)

> 테이블 내 데이터를 조회, 삽입, 수정, 삭제할 때 사용합니다.

| 명령어      | 설명                        |
|-------------|-----------------------------|
| `SELECT`    | 데이터 조회                 |
| `INSERT`    | 데이터 삽입                 |
| `UPDATE`    | 데이터 수정                 |
| `DELETE`    | 데이터 삭제                 |

> 📝 **주의**:  
> - `UPDATE`, `DELETE` 명령어는 **WHERE 절** 사용에 주의해야 하며, 그렇지 않으면 모든 데이터가 변경 또는 삭제될 수 있습니다.  
> - `SELECT`는 데이터 변경 없이 조회만 수행합니다.

---

## 🔐 DCL (Data Control Language)

> 사용자 권한 제어 및 보안 관리에 사용됩니다.

| 명령어      | 설명                        |
|-------------|-----------------------------|
| `GRANT`     | 권한 부여                   |
| `REVOKE`    | 권한 회수                   |

---

## 🏷️ SQL 명명 규칙 (Naming Conventions)

> SQL 객체(테이블, 컬럼 등)의 이름을 지을 때는 **가독성, 유지보수, 일관성**을 고려해야 합니다.

| 규칙       | 설명                                         |
|------------|----------------------------------------------|
| 문자       | 영문 소문자 권장 (`snake_case` 스타일)       |
| 숫자       | 이름에 포함 가능, 단 처음에 숫자 오는 것 주의 |
| 특수문자   | 사용 금지 (언더스코어 `_`만 허용)             |
| 길이       | 30자 이하 권장                               |
| 예약어     | SQL 예약어 사용 금지 (`select`, `from` 등)    |

---

### 📦 테이블명 규칙

| 규칙                    | 예시                     |
|-------------------------|--------------------------|
| 복수형 사용              | `users`, `orders`, `products` |
| 기능/역할 기반 명명      | `user_roles`, `order_items`   |
| 접두사/스키마 사용 (선택) | `auth_users`, `sales_orders`  |

---

### 🧩 컬럼명 규칙

| 규칙                          | 예시                          |
|-------------------------------|-------------------------------|
| `snake_case` 스타일 권장       | `user_id`, `created_at`       |
| 명확하고 구체적으로 작성       | `product_price` 대신 `price` 보다 구체적 |
| 불린값 컬럼은 접두사 활용      | `is_active`, `has_discount`   |

---

## ⚠️ 제약 조건 (Constraints) 정리

데이터베이스 무결성을 유지하고, 데이터의 정확성과 관계를 보장하기 위한 규칙입니다.  
잘못된 데이터 입력, 삭제, 변경을 방지하여 데이터베이스 안정성을 높입니다.

---

### 1. 제약 조건 사용 목적

- **무결성 유지**  
  잘못된 데이터 삽입 방지

- **오류 방지**  
  부적절한 입력, 삭제, 변경 방지

- **관계 유지**  
  테이블 간 연결의 일관성 확보

---

### 2. 제약 조건 종류

| 제약 조건명             | 설명                                         |
|-------------------------|----------------------------------------------|
| **Primary Key (기본 키)** | 행을 고유하게 식별하는 키, 중복/NULL 불가    |
| **Foreign Key (외래 키)** | 다른 테이블 기본 키 참조, 관계 설정          |
| **Unique**               | 컬럼 값 중복 불가, NULL은 하나만 허용 가능    |
| **Check**                | 컬럼 값이 특정 조건을 만족하는지 검증         |
| **NOT NULL**             | 컬럼에 반드시 값 존재, NULL 불가               |
| **Default**              | 값 미입력 시 기본값 자동 설정                  |

---

# 📌 JOIN 이란?

`JOIN`은 두 개 이상의 테이블을 **공통된 컬럼**을 기준으로 연결해, 하나의 통합된 결과 집합을 생성하는 SQL 명령어입니다.

---

## 🧩 JOIN 종류

### 🔗 1. INNER JOIN

- 두 테이블 모두에서 **일치하는 값이 존재하는 행만** 반환합니다.
- 일치하지 않는 데이터는 제외됩니다.

✅ 교집합

---

### ⬅️ 2. LEFT JOIN (LEFT OUTER JOIN)

 ✅ A 중심의 조인 (왼쪽 기준)
-- A의 모든 행 + B에서 일치하는 값
-- B에 값이 없으면 **NULL** 로 채움

---

### 📤 3. RIGHT JOIN (RIGHT OUTER JOIN)
오른쪽 테이블(B)의 모든 행을 포함하고,

왼쪽 테이블(A)에 일치하는 데이터가 있다면 함께 출력합니다.

일치하지 않는 경우에는 **NULL** 이 반환됩니다.

✅ B 중심의 조인 (오른쪽 기준)

---

### ❌ 4. CROSS JOIN

두 테이블의 **모든 조합(카티션 곱)** 을 반환합니다.

조인 조건이 없으므로 결과 행 수 = A 행 수 × B 행 수

✅ 조합 가능한 모든 경우

---

### 📝 JOIN 비교 요약표

| JOIN 종류     | 기준 테이블 | 일치 여부        | 포함 여부                    | NULL 포함 여부        |
|---------------|--------------|-------------------|-------------------------------|------------------------|
| INNER JOIN    | 양쪽         | 일치하는 경우만   | ✅ 일치 데이터만              | ❌ 없음                |
| LEFT JOIN     | 왼쪽 (A)     | 일치 여부 무관    | ✅ A 전부 + B 일부            | ✅ B 없으면 NULL       |
| RIGHT JOIN    | 오른쪽 (B)  | 일치 여부 무관    | ✅ B 전부 + A 일부            | ✅ A 없으면 NULL       |
| CROSS JOIN    | 없음         | 조건 없음         | ✅ 전체 조합 (A × B)          | ❌ 없음 

---

## 📌 1. 스토어드 프로시저란?

MySQL에서 조건문, 반복문 등을 이용한 **프로그래밍 로직을 SQL 내부에 저장하고 실행**할 수 있는 데이터베이스 객체입니다.  
- 일종의 "함수(Function)"처럼 **재사용 가능한 SQL 묶음**
- 비즈니스 로직을 DB에 직접 작성해 서버와의 통신 최소화

---

## 🧱 데이터베이스 개체(DB Object)란?

| 종류                  | 설명                             |
|-----------------------|----------------------------------|
| 테이블 (Table)         | 데이터를 저장하는 기본 구조        |
| 뷰 (View)              | 가상의 테이블 (조회 전용)         |
| 스토어드 프로시저      | 저장된 SQL 로직 (프로시저)         |
| 함수 (Function)        | 하나의 값을 반환하는 저장된 로직   |
| 트리거 (Trigger)       | 이벤트 발생 시 자동 실행되는 로직  |

---

## 🛠️ 스토어드 프로시저 기본 구조

1. **DELIMITER 변경**  
   - 기본 SQL 종료 구분자인 `;` 대신 `$$` 또는 `^^` 등을 사용  
   - 여러 SQL 문을 하나의 블록으로 인식시키기 위함

2. **프로시저 정의**  
   - `CREATE PROCEDURE 프로시저명()`  
   - `BEGIN ~ END` 내부에 SQL 프로그래밍 작성

3. **프로시저 실행**  
   - `CALL 프로시저명();`

4. **프로시저 삭제**  
   - `DROP PROCEDURE 프로시저명;`

---

## ✅ 조건문 (IF ~ ELSE)

스토어드 프로시저에서 **조건 분기**를 구현할 수 있습니다.

- `IF 조건 THEN`  
- `ELSE`  
- `END IF;`

✔ 예: 특정 숫자 조건 비교 후 메시지 반환 등

---

## 🔄 다중 분기문 (CASE)

SQL에서 **switch-case**처럼 사용됩니다.

- `CASE WHEN 조건 THEN ...`  
- `ELSE ...`  
- `END CASE;`

| 점수     | 결과   |
|----------|--------|
| 90 이상  | A 학점 |
| 80 이상  | B 학점 |
| 70 이상  | C 학점 |
| 그 외    | F 학점 |

---

## 📍 사용 예시

- 등급 계산 자동화  
- 로그인 성공/실패 판단  
- 상태값에 따른 처리 흐름 구분  
- 반복 작업의 로직 캡슐화

---

# 🔎 **트리거란?**

- 특정 테이블에서 **INSERT**, **UPDATE**, **DELETE** 이벤트 발생 시  
  자동으로 실행되는 저장 프로시저 같은 객체  
- 직접 호출 ❌ (CALL 사용 불가)  
- **이벤트 발생 시에만 자동 실행 ⚡**

---

### 🎯 **트리거 사용 목적**

- **자동화된 작업 처리**  
  ex) 회원 가입 시 가입 로그 자동 기록 📝  
- **데이터 무결성 유지**  
  ex) 주문 후 결제 테이블 자동 삽입으로 오류 방지 ✅  

---

### 💡 **트리거 활용 예시**

| 이벤트 상황         | 자동 수행 작업 예시               |
| ------------------ | ------------------------------- |
| 🗑️ 행 삭제          | 삭제된 데이터 로그 기록           |
| ➕ 데이터 삽입      | 관련 값 자동 계산 및 추가         |
| ✏️ 회원 정보 수정   | 수정 시간 자동 갱신               |

---

### ⚙️ **트리거 동작 방식**

- 이벤트 발생 시 자동 실행 (INSERT, UPDATE, DELETE만 해당)  
- SELECT 이벤트는 트리거 대상 아님 ❌  
- 호출 불가, 이벤트 발생시에만 작동  

---

### 📋 **트리거 종류**

| 구분               | 설명                         |
| ------------------ | ---------------------------- |
| ⏳ **BEFORE 트리거** | 작업 수행 전에 실행           |
| ⏰ **AFTER 트리거**  | 작업 수행 후에 실행           |

- **모든 트리거는 행 단위 실행** (`FOR EACH ROW`) 🔄

---

### 🛠️ **트리거 실무 활용**

- 이벤트 발생 시 자동 로그 기록 🕵️‍♂️  
- 재고 수량 자동 조정 📦  
- 포인트 자동 적립 ⭐ 등 비즈니스 로직 자동화  

---

### ⚠️ **주의 사항**

- 남용 시 디버깅 어려움 및 성능 저하 위험 ⚠️  
- 필요한 곳에만 최소한으로 사용 권장  

---

## 2️⃣ **트리거 기본 문법**

DELIMITER $$

    CREATE TRIGGER 트리거명
        BEFORE INSERT
        ON 테이블명
        FOR EACH ROW
    BEGIN
        -- 실행할 SQL 코드 작성 --
    END $$

    DELIMITER ;
---

# 📘 데이터베이스 정규화

---

## 📌 1. 정규화(Normalization) 개요

정규화란 **중복된 데이터를 제거**하고, **데이터의 무결성을 유지**하기 위해 테이블을 구조적으로 분해하는 과정입니다.  
즉, 데이터베이스 내에서 **논리적으로 불필요한 중복**을 제거하고, 데이터 변경 시 발생할 수 있는 **이상현상(Anomaly)**을 방지하기 위한 중요한 설계 기법입니다.

> ❗ 정규화를 수행하지 않으면 삽입 이상, 수정 이상, 삭제 이상 등 다양한 데이터 무결성 문제가 발생할 수 있습니다.

---

## 🎯 2. 정규화의 목적

| 목적             | 설명 |
|------------------|------|
| ✅ 중복 최소화    | 동일한 데이터의 반복 저장을 방지하여 공간 효율 및 데이터 일관성 확보 |
| ✅ 무결성 유지    | 데이터 변경 시 전체 데이터의 일관성과 정확성을 보장 |
| ✅ 이상현상 방지 | 삽입/수정/삭제 시 발생할 수 있는 오류를 방지 |
| ✅ 유지보수 용이 | 테이블 구조가 간결하고 명확하여 관리가 쉬움 |

---

## 🧩 3. 정규화 종류 (Normal Forms)

정규화는 단계적으로 수행되며, 각 단계는 이전 단계의 조건을 만족한 상태에서 추가적인 조건을 충족해야 합니다.

### 📘 제 1 정규형 (1NF)
- **조건**: 모든 컬럼은 **원자값(Atomic Value)**만을 가져야 함
- **예시**: 하나의 셀에 여러 값이 들어가 있으면 안 됨 (예: `과목: 수학, 과학` → ❌)

### 📘 제 2 정규형 (2NF)
- **조건**: 1NF + 기본키에 대해 **완전 함수 종속**
- **개념**: 복합키를 사용하는 경우, 모든 비주요 속성은 기본키 전체에 의존해야 함
- **해결**: 부분 함수 종속 제거

### 📘 제 3 정규형 (3NF)
- **조건**: 2NF + **이행적 종속 제거**
- **개념**: 비주요 속성이 또 다른 비주요 속성에 종속되지 않도록 함

### 📘 BCNF (보이스-코드 정규형)
- **조건**: 모든 결정자가 **후보키** 여야 함
- **특징**: 3NF보다 더 엄격한 기준 적용
- **예외 처리**: 일부 경우에는 3NF를 만족해도 BCNF는 위배될 수 있음

---

## 💡 cf. 정규형 (Normal Form) 이란?

> 정규형이란 데이터베이스 테이블이 정규화 과정을 통해 달성해야 할 **일정한 규칙이나 형식**을 의미합니다.

---

## 🚨 4. 정규화의 필요성 예시

### ❌ 비정규화된 테이블

| student_id | student_name | course_id | course_name | course_instructor |
|------------|--------------|-----------|-------------|--------------------|
| 1          | 김태양       | 101       | 슬립테크     | 김준일             |
| 1          | 김태양       | 102       | IoT         | 이승아             |
| 2          | 홍기수       | 102       | IoT         | 이승아             |

### ❗ 문제점
1. **중복 데이터**  
   - 학생 정보, 강의 정보, 강사명이 여러 행에 중복 저장됨
2. **이상 현상 발생**
   - **삽입 이상**: 수강생이 없으면 강의 정보만 단독 등록 불가
   - **수정 이상**: 같은 강사명을 여러 행에서 모두 수정해야 함
   - **삭제 이상**: 학생을 삭제할 때 강의 정보까지 사라질 위험

---

## ⚙️ 5. 정규화 단계 요약

| 단계 | 정규형 | 조건 | 해결하는 문제 |
|------|--------|------|----------------|
| 1단계 | 1NF | 모든 컬럼은 원자값 | 반복 그룹 제거 |
| 2단계 | 2NF | 1NF 만족 + 완전 함수 종속 | 부분 종속 제거 |
| 3단계 | 3NF | 2NF 만족 + 이행적 종속 제거 | 비주요 속성 간 종속 제거 |
| 보완 | BCNF | 모든 결정자가 후보키 | 후보키 아닌 결정자 제거 |

---
